## 21. Reverse a string : [link](https://leetcode.com/problems/reverse-words-in-a-string/?envType=study-plan-v2&envId=top-interview-150)
### Notes : Let’s take:
" hello world "

Step 1: Reverse entire string
" dlrow olleh "

Step 2: Reverse each word     

Reverse "dlrow" → "world"
Reverse "olleh" → "hello"    
String now:     
" world hello "

Step 3: Remove extra spaces

Remove leading spaces → "world hello "
Remove trailing spaces → "world hello"
Replace multiple spaces with one → "world hello"
ℹ️ Here, no trailing spaces in the final example, but if we had "world___hello" (where _ represents extra spaces), it would become "world hello".

✅ Final Output: "world hello"

### Time Complexity : O(n)

### Code : 
```bash
class Solution {
public:
    string reverseWords(string s) {
        // Step 1: Reverse the whole string
        reverse(s.begin(), s.end());
        int start = 0; 
        int end = s.size();

        // Step 2: Reverse each word
        for (int i = 0; i < s.size(); i++) {
            while (i < s.size() && s[i] != ' ') i++;
            end = i;
            reverse(s.begin() + start, s.begin() + end);
            start = i + 1;
        }

        // Step 3: Remove leading spaces
        start = 0; 
        while (start < s.size() && s[start] == ' ') start++;
        s.erase(0, start);

        // Step 4: Remove trailing spaces
        end = s.size() - 1;
        while (end >= 0 && s[end] == ' ') end--;
        s.erase(end + 1, s.size() - end - 1);

        // Step 5: Remove multiple spaces in between
        for (int i = 0; i < s.size() - 1; ) {
            if (s[i] == ' ' && s[i + 1] == ' ') {
                s.erase(i, 1);
            } else {
                i++;
            }
        }

        return s;
    }
}; // the whole string have been reversed

```
---
## 22. ZigZag Conversion : [link](https://leetcode.com/problems/reverse-words-in-a-string/?envType=study-plan-v2&envId=top-interview-150)
### Notes : Problem

Convert a string into zigzag form with numRows and then read row by row.

### Approach

Use a vector of strings, one for each row.
1) Traverse characters:
2) Add current char to correct row.
- Flip direction at top (0) or bottom (numRows-1).
- Move row index up or down.

3) Finally, concatenate all rows.

Key Points
Edge case: if numRows <= 1, just return s.

Time Complexity: O(n)

Space Complexity: O(n)


### Code : 
```bash
class Solution {
public:

    string convert(string s, int numRows) {
    
    if(numRows <= 1) return s;

    vector<string>v(numRows, ""); 

    int j = 0, dir = -1;

    for(int i = 0; i < s.length(); i++)
    {

        if(j == numRows - 1 || j == 0) dir *= (-1); 
		 
        v[j] += s[i];

        if(dir == 1) j++;

        else j--;
    }

    string res;

    for(auto &it : v) res += it; 

    return res;

    }
};

```
--- 
## 23. Find the Index of the First Occurrence in a String : [link](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150)

### Notes : Intuition
The function is trying to find the index of the first occurrence of the needle string within the haystack string. If the needle is not found in the haystack, it returns -1.

### Approach
1. Use a loop to iterate through the haystack string. The loop starts at index i = 0 and goes up to i = haystack.length() - needle.length(). This is done to ensure that there are enough characters left in the haystack for the needle to fit.

2. Within the loop, check substrings of length equal to the length of the needle starting from the current index i up to i + needle.length(). If any of these substrings matches the needle, return the current index i.

3. If the loop completes without finding a match, return -1.

### Complexity
Time complexity: O(n * m)
Space complexity: O(1)

### Code : 
```bash
class Solution {
public:
    int strStr(string haystack, string needle) {
        if(haystack.length()<needle.length()){
            return -1;

        }
        for( int i = 0 ; i<= haystack.length()- needle.length() ; i++){
            if(haystack.substr(i,needle.length())==needle){ //slicing technique is been used substr function to slice it with the i'th end point to the subtraction of the haystack and needle
                return i ;
            }
        }
        return -1;
    }
};
```
---
## 24. Text Justification : [link](https://leetcode.com/problems/text-justification/description/?envType=study-plan-v2&envId=top-interview-150)  hard
### Intuition
Think of the sentence you are building as a sliding window over the words array:

Collect words left‑to‑right until the next word would overflow maxWidth.
Justify the words already in the window before moving on.
Special‑case the last line (it must be left‑aligned).
This “fill‑then‑flush” pattern lets us handle every word exactly once, keeping the solution linear and easy to reason about.

### Approach
Pointers & running length

left = left index of the current sentence.
right = right index we are trying to add next.
sentenceLength = current sentence length (letters + one space per word).
When the next word doesn’t fit

Step right back (right--) so the window ends at the last word that did fit.

Compute remaining spaces:
```
spacesToDistribute = maxWidth - sentenceLength + (right - left + 1)
gaps  = right - left             // number of space gaps
base  = spacesToDistribute / gaps   // minimum spaces per gap
extra = spacesToDistribute % gaps   // extra spaces to spread from the left
Stitch the sentence:
```

Word ➜ base spaces ➜ maybe one extra space (while extra > 0).
If the sentence had only one word, pad with spaces on the right.

When processing the very last line

Join words with single spaces (" ").
Pad the right side to reach maxWidth (left‑aligned requirement).
Move the window forward and repeat until every word is placed.

### Complexity
Time: O(n) – each word is touched once.
Space: O(n) – for the resulting ans vector (output).

### Code : 
```
class Solution {
public:
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        vector<string> result;
        int n = words.size();
        int index = 0;

        while (index < n) {
            int totalChars = words[index].size();
            int last = index + 1;

            while (last < n && totalChars + words[last].size() + (last - index) <= maxWidth) {
                totalChars += words[last].size();
                last++;
            }

            string line;
            int gaps = last - index - 1;

            if (last == n || gaps == 0) {
                for (int i = index; i < last; i++) {
                    line += words[i];
                    if (i < last - 1) line += " ";
                }
                line += string(maxWidth - line.size(), ' ');
            } else {
                int spaces = (maxWidth - totalChars) / gaps;
                int extraSpaces = (maxWidth - totalChars) % gaps;

                for (int i = index; i < last - 1; i++) {
                    line += words[i];
                    line += string(spaces + (i - index < extraSpaces ? 1 : 0), ' ');
                }
                line += words[last - 1];
            }

            result.push_back(line);
            index = last;
        }

        return result;
    }
};
```
---
## 25. Valid palindrome : [link](https://leetcode.com/problems/valid-palindrome/?envType=study-plan-v2&envId=top-interview-150)
### Notes : Approach
This code is an implementation of a solution to determine if a given string is a palindrome. A string is considered a palindrome if it reads the same forwards and backwards, ignoring spaces, punctuation, and letter casing.

The approach used in this solution is a two-pointer technique, where two pointers are maintained, one at the start of the string and the other at the end of the string. The two pointers move towards each other until they meet in the middle of the string.

At each iteration of the while loop, the characters pointed to by the start and last pointers are checked. If either of the characters is not a letter or digit (e.g., a space or punctuation), the pointer is moved one step to the right (for start) or one step to the left (for last) until a letter or digit is found.

If both characters are letters or digits, they are converted to lowercase and compared. If they are not equal, the function returns false, as the string is not a palindrome. If they are equal, both pointers are moved one step to the right and left, respectively.

The while loop continues until the start pointer is greater than the last pointer, indicating that all the characters have been checked and that the string is a palindrome. The function then returns true.

### Complexity
Time complexity:
The time complexity of this solution is O(n), where n is the length of the string. This is because, in the worst case, all characters in the string need to be checked once, so the number of operations is proportional to the length of the string.

### Space complexity:
The space complexity of this solution is O(1), as no additional data structures are used, and only a constant amount of memory is required for the start and last pointers and a few variables.

Code : 
```
class Solution {
public:
    bool isPalindrome(string s) {
        int start = 0 ; 
        int end = s.size()-1 ; 
        while(start<= end ){
            if(!isalnum(s[start])){start++; continue;}      
            if(!isalnum(s[end])){end--; continue;}
            if(tolower(s[start])!= tolower(s[end])) return false ;  
            else{
                start++; 
                end--; 
            }
        }
        return true;
    }
};
```

## 26. Is Subsequence : [link](https://leetcode.com/problems/is-subsequence/solutions/7099285/beats-100-on-runtime/?envType=study-plan-v2&envId=top-interview-150)
### Notes : Intuition
First we need to think about comparison of two strings

### Approach
We need two variables (eg. i and j) setting to 0, after that while j less than length of t, the process goes on. If i is less than length of s and ith index of s is equal to jth index of t, we increment both variables, else we increment only j.
Finally we check if i is equal to length of s return True, else False.

### Complexity : 
Time complexity : O(n)
space complexity : O(1)

### Code : 
```
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int n = s.length();
        int m = t.length();
        int i = 0 , j = 0 ;
        while(i<n && j <m ){
            if(s[i]==t[j]){
                 i++ ; 
            }
            j++;
        }
        if(i == n ){
            return true ;
        }
        else{ 
            return false ; 
        }
    }
};
```
---
## 27. Two Sum II : [link](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/?envType=study-plan-v2&envId=top-interview-150)
### Notes : ✅ Intuition
- The array is sorted, so we can use the **two-pointer technique**.
- Start from both ends:
  - If the sum is **greater than target**, move the right pointer left to reduce the sum.
  - If the sum is **less than target**, move the left pointer right to increase the sum.
- This approach is **better than brute force** because it runs in linear time.

### ✅ Approach
1. Initialize:
   - `left = 0`
   - `right = numbers.size() - 1`
2. While `left < right`:
   - Calculate `sum = numbers[left] + numbers[right]`
   - If `sum == target` → return `{left+1, right+1}` (1-based indexing)
   - If `sum > target` → move `right--`
   - Else → move `left++`
3. Return empty vector if no solution exists (though problem guarantees one).

### ✅ Complexity
- **Time Complexity:** `O(n)`  
  Each element is visited at most once.
- **Space Complexity:** `O(1)`  
  No extra data structures are used.

### Code : in cpp 
```
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0, right = numbers.size() - 1;

        while (left < right) {
            int sum = numbers[left] + numbers[right];
            if (sum == target) return {left + 1, right + 1};
            else if (sum > target) right--;
            else left++;
        }
        return {}; // Problem guarantees a solution
    }
};
```
--- 

## 28. Container with the most water : [link](https://leetcode.com/problems/container-with-most-water/?envType=study-plan-v2&envId=top-interview-150)
### Notes : ✅ Intuition
- The width between two lines decreases as you move pointers inward.
- The **area** is calculated as:
area = min(height[left], height[right]) * (right - left)
- To maximize the area:
- Start with the widest container (leftmost and rightmost lines).
- Move the pointer pointing to the **shorter line** inward because:
  - The limiting factor is the **shorter height**.
  - Moving the taller line inward won’t help increase the area.

### ✅ Approach (Two-Pointer Technique)
1. Initialize:
 - `left = 0`, `right = height.size() - 1`
 - `maxArea = 0`
2. While `left < right`:
 - Compute `currentArea = min(height[left], height[right]) * (right - left)`
 - Update `maxArea = max(maxArea, currentArea)`
 - Move the pointer at the **shorter line** inward:
   - If `height[left] < height[right]` → `left++`
   - Else → `right--`
3. Return `maxArea`

---

### ✅ Complexity
- **Time Complexity:** `O(n)`  
Each pointer moves at most `n` steps.
- **Space Complexity:** `O(1)`  
No extra data structures used.

---

### ✅ Code (C++)
```cpp
class Solution {   
public:
  int maxArea(vector<int>& height) {
      int left = 0;
      int right = height.size() - 1;
      int maxArea = 0;

      while (left < right) {
          int currentArea = min(height[left], height[right]) * (right - left);
          maxArea = max(maxArea, currentArea);

          if (height[left] < height[right]) {
              left++;
          } else {
              right--;
          }
      }

      return maxArea;
  }
};
```
--- 
## 29. THREE SUM : [link](https://leetcode.com/problems/3sum/?envType=study-plan-v2&envId=top-interview-150)
### Notes : ## 🚀 Approach
We use **Sorting + Two Pointer Technique**.

1. **Sort the array**  
   - Sorting makes it easier to use two pointers and handle duplicates.

2. **Iterate with index `i`** (first element of triplet)  
   - Skip duplicate values to avoid repeating triplets.

3. **Use two pointers** (`j` and `k`) for remaining elements:  
   - `j = i + 1` (next element after `i`)  
   - `k = nums.size() - 1` (last element)

4. **Check the sum:**  
   - If `nums[i] + nums[j] + nums[k] > 0` → move `k--` (reduce sum).  
   - If `< 0` → move `j++` (increase sum).  
   - If `== 0` → store the triplet, then skip duplicates for `j`.

---

### Time Complexity : 
Complexity Analysis
 - Time Complexity: O(n^2)
 - Outer loop: O(n)

Two-pointer search inside: O(n)
Space Complexity: O(1) (excluding output storage)

## 📝 Code (C++)
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());

        for (int i = 0; i < nums.size(); i++) {
            if (i > 0 && nums[i] == nums[i-1]) continue; // Skip duplicates for i

            int j = i + 1;
            int k = nums.size() - 1;

            while (j < k) {
                int total = nums[i] + nums[j] + nums[k];

                if (total > 0) {
                    k--;
                } else if (total < 0) {
                    j++;
                } else {
                    res.push_back({nums[i], nums[j], nums[k]});
                    j++;

                    // Skip duplicates for j
                    while (j < k && nums[j] == nums[j-1]) {
                        j++;
                    }
                }
            }
        }
        return res;
    }
};
```
## 30. Reverse of a number : 
``` (my code )
#include<iostream>
using namespace std ;

int main(){
    int n; 
    cin>>n;
    int revNum = 0 ;
    while(n>0){
        int ld = n % 10 ;
        revNum = (revNum * 10) + ld;
        n = n/10 ; 
    }
    cout << revNum ; 
}
```
leetcode : 
```
class Solution {                      
public:
    int reverse(int x) {
        int r=0;      
        while(x){
         if (r>INT_MAX/10 || r<INT_MIN/10) return 0; 
         r=r*10+x%10; 
         x=x/10; 
        } 
        return r;  
    }
};   //beats 100%
```

 
