## 21. Reverse a string : [link](https://leetcode.com/problems/reverse-words-in-a-string/?envType=study-plan-v2&envId=top-interview-150)
### Notes : Let’s take:
" hello world "

Step 1: Reverse entire string
" dlrow olleh "

Step 2: Reverse each word

Reverse "dlrow" → "world"
Reverse "olleh" → "hello"
String now:
" world hello "

Step 3: Remove extra spaces

Remove leading spaces → "world hello "
Remove trailing spaces → "world hello"
Replace multiple spaces with one → "world hello"
ℹ️ Here, no trailing spaces in the final example, but if we had "world___hello" (where _ represents extra spaces), it would become "world hello".

✅ Final Output: "world hello"

### Time Complexity : O(n)

### Code : 
```bash
class Solution {
public:
    string reverseWords(string s) {
        // Step 1: Reverse the whole string
        reverse(s.begin(), s.end());
        int start = 0; 
        int end = s.size();

        // Step 2: Reverse each word
        for (int i = 0; i < s.size(); i++) {
            while (i < s.size() && s[i] != ' ') i++;
            end = i;
            reverse(s.begin() + start, s.begin() + end);
            start = i + 1;
        }

        // Step 3: Remove leading spaces
        start = 0; 
        while (start < s.size() && s[start] == ' ') start++;
        s.erase(0, start);

        // Step 4: Remove trailing spaces
        end = s.size() - 1;
        while (end >= 0 && s[end] == ' ') end--;
        s.erase(end + 1, s.size() - end - 1);

        // Step 5: Remove multiple spaces in between
        for (int i = 0; i < s.size() - 1; ) {
            if (s[i] == ' ' && s[i + 1] == ' ') {
                s.erase(i, 1);
            } else {
                i++;
            }
        }

        return s;
    }
}; // the whole string have been reversed

```
---
## 22. ZigZag Conversion : [link](https://leetcode.com/problems/reverse-words-in-a-string/?envType=study-plan-v2&envId=top-interview-150)
### Notes : Problem

Convert a string into zigzag form with numRows and then read row by row.

### Approach

Use a vector of strings, one for each row.
1) Traverse characters:
2) Add current char to correct row.
- Flip direction at top (0) or bottom (numRows-1).
- Move row index up or down.

3) Finally, concatenate all rows.

Key Points
Edge case: if numRows <= 1, just return s.

Time Complexity: O(n)

Space Complexity: O(n)


### Code : 
```bash
class Solution {
public:

    string convert(string s, int numRows) {
    
    if(numRows <= 1) return s;

    vector<string>v(numRows, ""); 

    int j = 0, dir = -1;

    for(int i = 0; i < s.length(); i++)
    {

        if(j == numRows - 1 || j == 0) dir *= (-1); 
		 
        v[j] += s[i];

        if(dir == 1) j++;

        else j--;
    }

    string res;

    for(auto &it : v) res += it; 

    return res;

    }
};

```
--- 
## 23. Find the Index of the First Occurrence in a String : [link](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150)

### Notes : Intuition
The function is trying to find the index of the first occurrence of the needle string within the haystack string. If the needle is not found in the haystack, it returns -1.

### Approach
1. Use a loop to iterate through the haystack string. The loop starts at index i = 0 and goes up to i = haystack.length() - needle.length(). This is done to ensure that there are enough characters left in the haystack for the needle to fit.

2. Within the loop, check substrings of length equal to the length of the needle starting from the current index i up to i + needle.length(). If any of these substrings matches the needle, return the current index i.

3. If the loop completes without finding a match, return -1.

### Complexity
Time complexity: O(n * m)
Space complexity: O(1)

### Code : 
```bash
class Solution {
public:
    int strStr(string haystack, string needle) {
        if(haystack.length()<needle.length()){
            return -1;

        }
        for( int i = 0 ; i<= haystack.length()- needle.length() ; i++){
            if(haystack.substr(i,needle.length())==needle){ //slicing technique is been used substr function to slice it with the i'th end point to the subtraction of the haystack and needle
                return i ;
            }
        }
        return -1;
    }
};
```
---
## 24. Text Justification : [link](https://leetcode.com/problems/text-justification/description/?envType=study-plan-v2&envId=top-interview-150)  hard
### Intuition
Think of the sentence you are building as a sliding window over the words array:

Collect words left‑to‑right until the next word would overflow maxWidth.
Justify the words already in the window before moving on.
Special‑case the last line (it must be left‑aligned).
This “fill‑then‑flush” pattern lets us handle every word exactly once, keeping the solution linear and easy to reason about.

### Approach
Pointers & running length

left = left index of the current sentence.
right = right index we are trying to add next.
sentenceLength = current sentence length (letters + one space per word).
When the next word doesn’t fit

Step right back (right--) so the window ends at the last word that did fit.

Compute remaining spaces:
```
spacesToDistribute = maxWidth - sentenceLength + (right - left + 1)
gaps  = right - left             // number of space gaps
base  = spacesToDistribute / gaps   // minimum spaces per gap
extra = spacesToDistribute % gaps   // extra spaces to spread from the left
Stitch the sentence:
```

Word ➜ base spaces ➜ maybe one extra space (while extra > 0).
If the sentence had only one word, pad with spaces on the right.

When processing the very last line

Join words with single spaces (" ").
Pad the right side to reach maxWidth (left‑aligned requirement).
Move the window forward and repeat until every word is placed.

### Complexity
Time: O(n) – each word is touched once.
Space: O(n) – for the resulting ans vector (output).

### Code : 
```
class Solution {
public:
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        vector<string> result;
        int n = words.size();
        int index = 0;

        while (index < n) {
            int totalChars = words[index].size();
            int last = index + 1;

            while (last < n && totalChars + words[last].size() + (last - index) <= maxWidth) {
                totalChars += words[last].size();
                last++;
            }

            string line;
            int gaps = last - index - 1;

            if (last == n || gaps == 0) {
                for (int i = index; i < last; i++) {
                    line += words[i];
                    if (i < last - 1) line += " ";
                }
                line += string(maxWidth - line.size(), ' ');
            } else {
                int spaces = (maxWidth - totalChars) / gaps;
                int extraSpaces = (maxWidth - totalChars) % gaps;

                for (int i = index; i < last - 1; i++) {
                    line += words[i];
                    line += string(spaces + (i - index < extraSpaces ? 1 : 0), ' ');
                }
                line += words[last - 1];
            }

            result.push_back(line);
            index = last;
        }

        return result;
    }
};
```
---
## 25. Valid palindrome : [link](https://leetcode.com/problems/valid-palindrome/?envType=study-plan-v2&envId=top-interview-150)
### Notes : Approach
This code is an implementation of a solution to determine if a given string is a palindrome. A string is considered a palindrome if it reads the same forwards and backwards, ignoring spaces, punctuation, and letter casing.

The approach used in this solution is a two-pointer technique, where two pointers are maintained, one at the start of the string and the other at the end of the string. The two pointers move towards each other until they meet in the middle of the string.

At each iteration of the while loop, the characters pointed to by the start and last pointers are checked. If either of the characters is not a letter or digit (e.g., a space or punctuation), the pointer is moved one step to the right (for start) or one step to the left (for last) until a letter or digit is found.

If both characters are letters or digits, they are converted to lowercase and compared. If they are not equal, the function returns false, as the string is not a palindrome. If they are equal, both pointers are moved one step to the right and left, respectively.

The while loop continues until the start pointer is greater than the last pointer, indicating that all the characters have been checked and that the string is a palindrome. The function then returns true.

### Complexity
Time complexity:
The time complexity of this solution is O(n), where n is the length of the string. This is because, in the worst case, all characters in the string need to be checked once, so the number of operations is proportional to the length of the string.

### Space complexity:
The space complexity of this solution is O(1), as no additional data structures are used, and only a constant amount of memory is required for the start and last pointers and a few variables.

Code : 
```
class Solution {
public:
    bool isPalindrome(string s) {
        int start = 0 ; 
        int end = s.size()-1 ; 
        while(start<= end ){
            if(!isalnum(s[start])){start++; continue;}      
            if(!isalnum(s[end])){end--; continue;}
            if(tolower(s[start])!= tolower(s[end])) return false ;  
            else{
                start++; 
                end--; 
            }
        }
        return true;
    }
};
```

## 26. Is Subsequence : [link](https://leetcode.com/problems/is-subsequence/solutions/7099285/beats-100-on-runtime/?envType=study-plan-v2&envId=top-interview-150)
### Notes : Intuition
First we need to think about comparison of two strings

### Approach
We need two variables (eg. i and j) setting to 0, after that while j less than length of t, the process goes on. If i is less than length of s and ith index of s is equal to jth index of t, we increment both variables, else we increment only j.
Finally we check if i is equal to length of s return True, else False.

### Complexity : 
Time complexity : O(n)
space complexity : O(1)

### Code : 
```
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int n = s.length();
        int m = t.length();
        int i = 0 , j = 0 ;
        while(i<n && j <m ){
            if(s[i]==t[j]){
                 i++ ; 
            }
            j++;
        }
        if(i == n ){
            return true ;
        }
        else{ 
            return false ; 
        }
    }
};
```

